
# Code generated by OpenFFI. DO NOT EDIT.
# Host code for PythonFuncs.proto

from PythonFuncs_pb2 import *
from ctypes import *
from typing import List
import platform
import os

xllrHandle = None
def free_openffi():
		return # TODO: implement free library. not supported by cdll.

def load_xllr():
	global xllrHandle
	if xllrHandle == None:
		xllrHandle = cdll.LoadLibrary(append_dynamic_lib_extension('xllr'))

def append_dynamic_lib_extension(fname):
	osname = platform.system()
	if osname == 'Windows':
		return fname + '.dll'
	elif osname == 'Darwin':
		return fname + 'dylib'
	else:
		return fname + '.so' # for everything that is not windows or mac, return .so



# Code to call foreign functions in module PythonicUtils via XLLR



# Call to foreign hello_world
def hello_world() -> ():
	
	# serialize parameters
	req = Void()
	

	# load XLLR
	load_xllr()
	
	# call function
	runtime_plugin = """xllr.python""".encode("utf-8")
	module_name = """PythonFuncs_openffi_guest""".encode("utf-8")
	func_name = """Foreignhello_world""".encode("utf-8")

	# in parameters
	in_params = req.SerializeToString()
	in_params_len = c_uint64(len(in_params))

	# ret
	ret = POINTER(c_ubyte)()
	out_ret = POINTER(POINTER(c_ubyte))(c_void_p(addressof(ret)))
	ret_len = c_uint64()
	out_ret_len = POINTER(c_uint64)(c_void_p(addressof(ret_len)))

# Currently disabling "ref params" support for python. To support that, one of parameters must be a list
#	oparams = POINTER(c_byte)()
#	out_params = POINTER(POINTER(c_byte))(c_void_p(addressof(oparams)))
#	oparams_len = c_int32()
#	out_params_len = POINTER(c_int32)(c_void_p(addressof(oparams_len)))

	is_error = c_int8()
	out_is_error = POINTER(c_int8)(c_void_p(addressof(is_error)))
	out_is_error.contents.value = 0

	global xllrHandle
	xllrHandle.call(runtime_plugin, len(runtime_plugin), \
									module_name, len(module_name), \
									func_name, len(func_name), \
									in_params, in_params_len, \
									None, None, \
									out_ret, out_ret_len, \
									out_is_error)
	
	
	# deserialize result

	protoData = string_at(out_ret.contents, out_ret_len.contents.value)

	# check for error
	if out_is_error.contents.value != 0:
		raise RuntimeError('\n'+str(protoData).replace("\\n", "\n"))

	ret = Void()
	ret.ParseFromString(protoData)

	return 
	



# Call to foreign div
def div( x:int, y:int) -> (float):
	
	# serialize parameters
	req = div_params()
	

	if getattr(req.x, 'extend', None) != None: # if repeated value, use append
		req.x.extend(x)
	elif getattr(req.x, 'CopyFrom', None) != None: # if proto message
		req.x.CopyFrom(x)
	else:
		req.x = x

	

	if getattr(req.y, 'extend', None) != None: # if repeated value, use append
		req.y.extend(y)
	elif getattr(req.y, 'CopyFrom', None) != None: # if proto message
		req.y.CopyFrom(y)
	else:
		req.y = y

	

	# load XLLR
	load_xllr()
	
	# call function
	runtime_plugin = """xllr.python""".encode("utf-8")
	module_name = """PythonFuncs_openffi_guest""".encode("utf-8")
	func_name = """Foreigndiv""".encode("utf-8")

	# in parameters
	in_params = req.SerializeToString()
	in_params_len = c_uint64(len(in_params))

	# ret
	ret = POINTER(c_ubyte)()
	out_ret = POINTER(POINTER(c_ubyte))(c_void_p(addressof(ret)))
	ret_len = c_uint64()
	out_ret_len = POINTER(c_uint64)(c_void_p(addressof(ret_len)))

# Currently disabling "ref params" support for python. To support that, one of parameters must be a list
#	oparams = POINTER(c_byte)()
#	out_params = POINTER(POINTER(c_byte))(c_void_p(addressof(oparams)))
#	oparams_len = c_int32()
#	out_params_len = POINTER(c_int32)(c_void_p(addressof(oparams_len)))

	is_error = c_int8()
	out_is_error = POINTER(c_int8)(c_void_p(addressof(is_error)))
	out_is_error.contents.value = 0

	global xllrHandle
	xllrHandle.call(runtime_plugin, len(runtime_plugin), \
									module_name, len(module_name), \
									func_name, len(func_name), \
									in_params, in_params_len, \
									None, None, \
									out_ret, out_ret_len, \
									out_is_error)
	
	
	# deserialize result

	protoData = string_at(out_ret.contents, out_ret_len.contents.value)

	# check for error
	if out_is_error.contents.value != 0:
		raise RuntimeError('\n'+str(protoData).replace("\\n", "\n"))

	ret = div_return()
	ret.ParseFromString(protoData)

	return ret.z
	



# Call to foreign concat_strings
def concat_strings( arr_of_strings:List[str]) -> (str):
	
	# serialize parameters
	req = concat_strings_params()
	

	if getattr(req.arr_of_strings, 'extend', None) != None: # if repeated value, use append
		req.arr_of_strings.extend(arr_of_strings)
	elif getattr(req.arr_of_strings, 'CopyFrom', None) != None: # if proto message
		req.arr_of_strings.CopyFrom(arr_of_strings)
	else:
		req.arr_of_strings = arr_of_strings

	

	# load XLLR
	load_xllr()
	
	# call function
	runtime_plugin = """xllr.python""".encode("utf-8")
	module_name = """PythonFuncs_openffi_guest""".encode("utf-8")
	func_name = """Foreignconcat_strings""".encode("utf-8")

	# in parameters
	in_params = req.SerializeToString()
	in_params_len = c_uint64(len(in_params))

	# ret
	ret = POINTER(c_ubyte)()
	out_ret = POINTER(POINTER(c_ubyte))(c_void_p(addressof(ret)))
	ret_len = c_uint64()
	out_ret_len = POINTER(c_uint64)(c_void_p(addressof(ret_len)))

# Currently disabling "ref params" support for python. To support that, one of parameters must be a list
#	oparams = POINTER(c_byte)()
#	out_params = POINTER(POINTER(c_byte))(c_void_p(addressof(oparams)))
#	oparams_len = c_int32()
#	out_params_len = POINTER(c_int32)(c_void_p(addressof(oparams_len)))

	is_error = c_int8()
	out_is_error = POINTER(c_int8)(c_void_p(addressof(is_error)))
	out_is_error.contents.value = 0

	global xllrHandle
	xllrHandle.call(runtime_plugin, len(runtime_plugin), \
									module_name, len(module_name), \
									func_name, len(func_name), \
									in_params, in_params_len, \
									None, None, \
									out_ret, out_ret_len, \
									out_is_error)
	
	
	# deserialize result

	protoData = string_at(out_ret.contents, out_ret_len.contents.value)

	# check for error
	if out_is_error.contents.value != 0:
		raise RuntimeError('\n'+str(protoData).replace("\\n", "\n"))

	ret = concat_strings_return()
	ret.ParseFromString(protoData)

	return ret.result
	





# Code to call foreign functions in module ComplexTypes via XLLR



# Call to foreign calculate_score
def calculate_score( gdata:game_data) -> (game_score):
	
	# serialize parameters
	req = calculate_score_params()
	

	if getattr(req.gdata, 'extend', None) != None: # if repeated value, use append
		req.gdata.extend(gdata)
	elif getattr(req.gdata, 'CopyFrom', None) != None: # if proto message
		req.gdata.CopyFrom(gdata)
	else:
		req.gdata = gdata

	

	# load XLLR
	load_xllr()
	
	# call function
	runtime_plugin = """xllr.python""".encode("utf-8")
	module_name = """PythonFuncs_openffi_guest""".encode("utf-8")
	func_name = """Foreigncalculate_score""".encode("utf-8")

	# in parameters
	in_params = req.SerializeToString()
	in_params_len = c_uint64(len(in_params))

	# ret
	ret = POINTER(c_ubyte)()
	out_ret = POINTER(POINTER(c_ubyte))(c_void_p(addressof(ret)))
	ret_len = c_uint64()
	out_ret_len = POINTER(c_uint64)(c_void_p(addressof(ret_len)))

# Currently disabling "ref params" support for python. To support that, one of parameters must be a list
#	oparams = POINTER(c_byte)()
#	out_params = POINTER(POINTER(c_byte))(c_void_p(addressof(oparams)))
#	oparams_len = c_int32()
#	out_params_len = POINTER(c_int32)(c_void_p(addressof(oparams_len)))

	is_error = c_int8()
	out_is_error = POINTER(c_int8)(c_void_p(addressof(is_error)))
	out_is_error.contents.value = 0

	global xllrHandle
	xllrHandle.call(runtime_plugin, len(runtime_plugin), \
									module_name, len(module_name), \
									func_name, len(func_name), \
									in_params, in_params_len, \
									None, None, \
									out_ret, out_ret_len, \
									out_is_error)
	
	
	# deserialize result

	protoData = string_at(out_ret.contents, out_ret_len.contents.value)

	# check for error
	if out_is_error.contents.value != 0:
		raise RuntimeError('\n'+str(protoData).replace("\\n", "\n"))

	ret = calculate_score_return()
	ret.ParseFromString(protoData)

	return ret.gscore
	



# Call to foreign gen_scores
def gen_scores() -> (List[game_score],int):
	
	# serialize parameters
	req = Void()
	

	# load XLLR
	load_xllr()
	
	# call function
	runtime_plugin = """xllr.python""".encode("utf-8")
	module_name = """PythonFuncs_openffi_guest""".encode("utf-8")
	func_name = """Foreigngen_scores""".encode("utf-8")

	# in parameters
	in_params = req.SerializeToString()
	in_params_len = c_uint64(len(in_params))

	# ret
	ret = POINTER(c_ubyte)()
	out_ret = POINTER(POINTER(c_ubyte))(c_void_p(addressof(ret)))
	ret_len = c_uint64()
	out_ret_len = POINTER(c_uint64)(c_void_p(addressof(ret_len)))

# Currently disabling "ref params" support for python. To support that, one of parameters must be a list
#	oparams = POINTER(c_byte)()
#	out_params = POINTER(POINTER(c_byte))(c_void_p(addressof(oparams)))
#	oparams_len = c_int32()
#	out_params_len = POINTER(c_int32)(c_void_p(addressof(oparams_len)))

	is_error = c_int8()
	out_is_error = POINTER(c_int8)(c_void_p(addressof(is_error)))
	out_is_error.contents.value = 0

	global xllrHandle
	xllrHandle.call(runtime_plugin, len(runtime_plugin), \
									module_name, len(module_name), \
									func_name, len(func_name), \
									in_params, in_params_len, \
									None, None, \
									out_ret, out_ret_len, \
									out_is_error)
	
	
	# deserialize result

	protoData = string_at(out_ret.contents, out_ret_len.contents.value)

	# check for error
	if out_is_error.contents.value != 0:
		raise RuntimeError('\n'+str(protoData).replace("\\n", "\n"))

	ret = gen_scores_return()
	ret.ParseFromString(protoData)

	return ret.scores,ret.total_score
	




