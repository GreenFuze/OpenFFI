package main

import (
	"fmt"
	"strings"
	"text/template"
)

const HostTemplate = `
# Code generated by OpenFFI. DO NOT EDIT.
# Host code for {{.ProtoIDLFilename}}
{{ $pfn := .ProtoIDLFilenameNoExtension}}
from {{.ProtobufFilename}} import *
from ctypes import *
from typing import List
import platform
import os

xllrHandle = None
def free_openffi():
		return # TODO: implement free library. not supported by cdll.

def load_xllr():
	global xllrHandle
	if xllrHandle == None:
		xllrHandle = cdll.LoadLibrary(append_dynamic_lib_extension('xllr'))

def append_dynamic_lib_extension(fname):
	osname = platform.system()
	if osname == 'Windows':
		return fname + '.dll'
	elif osname == 'Darwin':
		return fname + 'dylib'
	else:
		return fname + '.so' # for everything that is not windows or mac, return .so

{{range $mindex, $m := .Modules}}

# Code to call foreign functions in module {{$m.Name}} via XLLR

{{range $findex, $f := $m.Functions}}

# Call to foreign {{.ForeignFunctionName}}
def {{$f.ForeignFunctionName}}({{range $index, $elem := $f.ExpandedParameters}}{{if $index}},{{end}} {{$elem.Name}}:{{$elem.Type}}{{end}}) -> ({{range $index, $elem := $f.ExpandedReturn}}{{if $index}},{{end}}{{$elem.Type}}{{end}}):
	
	# serialize parameters
	req = {{$f.ProtobufRequestStruct}}()
	{{range $index, $elem := $f.ExpandedParameters}}

	if getattr(req.{{$elem.Name}}, 'extend', None) != None: # if repeated value, use append
		req.{{$elem.Name}}.extend({{$elem.Name}})
	else:
		req.{{$elem.Name}} = {{$elem.Name}}

	{{end}}
	
	in_params = req.SerializeToString()

	# load XLLR
	load_xllr()
	
	# call function
	runtime_plugin = append_dynamic_lib_extension("""xllr.python""").encode("utf-8")
	module_name = """{{$pfn}}_openffi_guest""".encode("utf-8")
	func_name = """Foreign{{$f.ForeignFunctionName}}""".encode("utf-8")

	ret = POINTER(c_byte)()
	out_ret = POINTER(POINTER(c_byte))(c_int32(addressof(ret)))
	ret_len = c_int32()
	out_ret_len = POINTER(c_int32)(c_int32(addressof(ret_len)))

# Currently disabling "ref params" support for python. To support that, one of parameters must be a list
#	oparams = POINTER(c_byte)()
#	out_params = POINTER(POINTER(c_byte))(c_int32(addressof(oparams)))
#	oparams_len = c_int32()
#	out_params_len = POINTER(c_int32)(c_int32(addressof(oparams_len)))

	is_error = c_int8()
	out_is_error = POINTER(c_int32)(c_int32(addressof(is_error)))

	global xllrHandle
	xllrHandle.call(runtime_plugin, len(runtime_plugin), \
									module_name, len(module_name), \
									func_name, len(func_name), \
									in_params, len(in_params), \
									None, None, \
									out_ret, out_ret_len, \
									out_is_error)
	
	
	# deserialize result
	res_len = out_ret_len.contents.value
	res_ptr = out_ret.contents

	protoData = bytes()

	# TODO: Find a better way to copy!!!!!
	i = 0
	while i < res_len:
		protoData += int(res_ptr[i]).to_bytes(1, 'big')
		i = i+1

	# TODO: free out_ret!!!!

	# check for error
	if out_is_error.contents != 0:
		raise Exception(str(protoData))

	ret = {{$f.ProtobufResponseStruct}}()
	ret.ParseFromString(protoData)

	return {{range $index, $elem := $f.ExpandedReturn}}{{if $index}},{{end}}ret.{{$elem.Name}}{{end}}
	

{{end}}

{{end}}
`

//--------------------------------------------------------------------
type HostTemplateParameters struct {
	ProtoIDLFilename       		string
	ProtoIDLFilenameNoExtension string
	ProtobufFilename       		string

	Modules []*HostTemplateModuleParameters
}
//--------------------------------------------------------------------
type HostTemplateModuleParameters struct {
	Name string
	Functions []*HostTemplateFunctionParameters
}
//--------------------------------------------------------------------
type HostTemplateFunctionParameters struct {
	ForeignFunctionName    string
	ProtobufRequestStruct  string
	ProtobufResponseStruct string
	ExpandedParameters     []*HostTemplateFunctionParameterData
	ExpandedReturn         []*HostTemplateFunctionParameterData
}
//--------------------------------------------------------------------
type HostTemplateFunctionParameterData struct {
	Name string
	Type string
}
//--------------------------------------------------------------------
func NewHostTemplateParameters(protoIDLFilename string) (*HostTemplateParameters, error){

	extensionIndex := strings.LastIndex(protoIDLFilename, ".")
	if extensionIndex == -1{
		return nil, fmt.Errorf("Cannot find extension in proto filename: %v", protoIDLFilename)
	}

	protoFilenameWithoutExtension := protoIDLFilename[:extensionIndex]

	gtp := &HostTemplateParameters{
		ProtoIDLFilename: protoIDLFilename,
		ProtoIDLFilenameNoExtension: protoFilenameWithoutExtension,
		ProtobufFilename: protoFilenameWithoutExtension + PROTOBUF_PYTHON_SUFFIX,
	}

	gtp.Modules = make([]*HostTemplateModuleParameters, 0)

	return gtp, nil
}
//--------------------------------------------------------------------
func NewHostTemplateFunctionParameterData(p *ParameterData) *HostTemplateFunctionParameterData{
	htfp := &HostTemplateFunctionParameterData{
		Name: p.Name,
	}

	htfp.Type = ProtoTypeToPythonType(p.Type)
	if p.IsArray{
		htfp.Type = fmt.Sprintf("List[%v]", htfp.Type)
	}

	return htfp
}
//--------------------------------------------------------------------
func (this *HostTemplateParameters) AddModule(m *Module){

	// add modules
	modParams := &HostTemplateModuleParameters{
		Name:      m.Name,
		Functions: make([]*HostTemplateFunctionParameters, 0),
	}

	// for each module, add the function

	for _, f := range m.Functions{

		funcParams := &HostTemplateFunctionParameters{
			ForeignFunctionName: f.Name,
			ProtobufRequestStruct: f.RequestName,
			ProtobufResponseStruct: f.ResponseName,
			ExpandedParameters: make([]*HostTemplateFunctionParameterData, 0),
			ExpandedReturn: make([]*HostTemplateFunctionParameterData, 0),
		}

		// generate parameters
		for _, p := range f.Parameters{
			funcParams.ExpandedParameters = append(funcParams.ExpandedParameters, NewHostTemplateFunctionParameterData(p))
		}

		for _, r := range f.Return{
			funcParams.ExpandedReturn = append(funcParams.ExpandedReturn, NewHostTemplateFunctionParameterData(r))
		}

		modParams.Functions = append(modParams.Functions, funcParams)
	}

	this.Modules = append(this.Modules, modParams)
}
//--------------------------------------------------------------------
func (this *HostTemplateParameters) Generate() (string, error){

	if this.ProtoIDLFilename == ""{
		return "", fmt.Errorf("ProtoIDLFilename is empty")
	}

	if this.ProtobufFilename == ""{
		return "", fmt.Errorf("ProtobufFilename is empty")
	}

	if this.Modules == nil || len(this.Modules) == 0{
		return "", fmt.Errorf("No functions defined")
	}

	for _, m := range this.Modules {

		if m.Name == ""{
			return "", fmt.Errorf("Module name is empty")
		}

		for _, f := range m.Functions {
			if f.ForeignFunctionName == "" {
				return "", fmt.Errorf("ForeignFunctionName is empty")
			}

			if f.ProtobufRequestStruct == "" {
				return "", fmt.Errorf("ProtobufRequestStruct is empty")
			}

			if f.ProtobufResponseStruct == "" {
				return "", fmt.Errorf("ProtobufResponseStruct is empty")
			}

			if f.ExpandedParameters == nil {
				return "", fmt.Errorf("ExpandedParameters is nil")
			}

			if f.ExpandedParameters == nil {
				return "", fmt.Errorf("ExpandedParameters is nil")
			}
		}
	}


	temp, err := template.New("Host").Parse(HostTemplate)
	if err != nil{
		return "", fmt.Errorf("Failed to parse HostTemplate, err: %v", err)
	}

	strbuf := strings.Builder{}

	err = temp.Execute(&strbuf, this)
	if err != nil{
		return "", fmt.Errorf("Failed to execute guest template, err: %v", err)
	}

	return strbuf.String(), nil
}
//--------------------------------------------------------------------
//--------------------------------------------------------------------
//--------------------------------------------------------------------
func NewHostTemplateFunctionParameters(foreignFunctionName string, protobufRequestStruct string, protobufResponseStruct string) *HostTemplateFunctionParameters{
	return &HostTemplateFunctionParameters{
		ForeignFunctionName:    foreignFunctionName,
		ProtobufRequestStruct:  protobufRequestStruct,
		ProtobufResponseStruct: protobufResponseStruct,
	}
}
//--------------------------------------------------------------------