package main

import (
	"fmt"
	"strings"
	"text/template"
)

const HostTemplate = `
# Code generated by OpenFFI. DO NOT EDIT.
# Host code for {{.ProtoIDLFilename}}

from {{.ProtobufFilename}} import *
from ctypes import *
from typing import List

xllrHandle = None
def free_openffi():
	if xllrHandle != None:
		cdll.FreeLibrary('xllr....') # TODO: extension by OS type

{{range $mindex, $m := .Modules}}
# Code to call foreign functions in module {{$m.Name}}
from {{$m.Name}} import *

{{range $findex, $f := $m.Functions}}

# Call to foreign {{.ForeignFunctionName}}
def {{$f.ForeignFunctionName}}({{range $index, $elem := $f.ExpandedParameters}}{{if $index}},{{end}} {{$elem.Name}}:{{$elem.Type}}{{end}}) -> ({{range $index, $elem := $f.ExpandedReturn}}{{if $index}},{{end}}{{$elem.Type}}{{end}}):
	
	# serialize parameters
	req = {{$f.ProtobufRequestStruct}}()
	{{range $index, $elem := $f.ExpandedParameters}}
	req.{{$elem.Name}} = {{$elem.Name}}
	{{end}}
	
	in_params = req.SerializeToString()

	# load XLLR
	if xllrHandle == None:
		xllrHandle = cdll.LoadLibrary('xllr....') # TODO: extension by OS type
	
	# call function
	runtime_plugin = """python""".encode("utf-8")
	module_name = """{{$m.Name}}.py""".encode("utf-8")
	func_name = """Foreign{{$f.Name}}.py""".encode("utf-8")

	ret = POINTER(c_byte)()
	out_ret = POINTER(POINTER(c_byte))(c_int32(addressof(ret)))
	ret_len = c_int32()
	out_ret_len = POINTER(c_int32)(c_int32(addressof(ret_len)))

# Currently disabling "ref params" support for python. To support that, one of parameters must be a list
#	oparams = POINTER(c_byte)()
#	out_params = POINTER(POINTER(c_byte))(c_int32(addressof(oparams)))
#	oparams_len = c_int32()
#	out_params_len = POINTER(c_int32)(c_int32(addressof(oparams_len)))

	is_error = c_int8()
	out_is_error = POINTER(c_int32)(c_int32(addressof(is_error)))

	xllrHandle.call_exported_function(runtime_plugin, len(runtime_plugin), \
									module_name, len(module_name), \
									func_name, len(func_name), \
									in_params, len(in_params), \
									None, None, \
									out_ret, out_ret_len, \
									out_is_error)

	# deserialize result
	res_len = pret_len.contents.value
	res_ptr = pret.contents 

	protoData = bytes()

	# TODO: Find a better way to copy
	i = 0
	while i < res_len:
		protoData += int(res_ptr[i]).to_bytes(1, 'big')
		i = i+1

	ret = {{$f.ProtobufResponseStruct}}()
	ret.ParseFromString(protoData)

	return {{range $index, $elem := $f.ExpandedReturn}}{{if $index}},{{end}}ret.{{$elem.Name}}{{end}}
	

{{end}}

{{end}}
`

//--------------------------------------------------------------------
type HostTemplateParameters struct {
	ProtoIDLFilename       string
	ProtobufFilename       string

	Modules []*HostTemplateModuleParameters
}
//--------------------------------------------------------------------
type HostTemplateModuleParameters struct {
	Name string
	Functions []*HostTemplateFunctionParameters
}
//--------------------------------------------------------------------
type HostTemplateFunctionParameters struct {
	ForeignFunctionName    string
	ProtobufRequestStruct  string
	ProtobufResponseStruct string
	ExpandedParameters     []*HostTemplateFunctionParameterData
	ExpandedReturn         []*HostTemplateFunctionParameterData
}
//--------------------------------------------------------------------
type HostTemplateFunctionParameterData struct {
	Name string
	Type string
}
//--------------------------------------------------------------------
func NewHostTemplateParameters(protoIDLFilename string) (*HostTemplateParameters, error){

	extensionIndex := strings.LastIndex(protoIDLFilename, ".")
	if extensionIndex == -1{
		return nil, fmt.Errorf("Cannot find extension in proto filename: %v", protoIDLFilename)
	}

	protoFilenameWithoutExtension := protoIDLFilename[:extensionIndex]

	gtp := &HostTemplateParameters{
		ProtoIDLFilename: protoIDLFilename,
		ProtobufFilename: protoFilenameWithoutExtension + PROTOBUF_PYTHON_SUFFIX,
	}

	gtp.Modules = make([]*HostTemplateModuleParameters, 0)

	return gtp, nil
}
//--------------------------------------------------------------------
func NewHostTemplateFunctionParameterData(p *ParameterData) *HostTemplateFunctionParameterData{
	htfp := &HostTemplateFunctionParameterData{
		Name: p.Name,
	}

	htfp.Type = ProtoTypeToPythonType(p.Type)
	if p.IsArray{
		htfp.Type = fmt.Sprintf("List[%v]", htfp.Type)
	}

	return htfp
}
//--------------------------------------------------------------------
func (this *HostTemplateParameters) AddModule(m *Module){

	// add modules
	modParams := &HostTemplateModuleParameters{
		Name:      m.Name,
		Functions: make([]*HostTemplateFunctionParameters, 0),
	}

	// for each module, add the function

	for _, f := range m.Functions{

		funcParams := &HostTemplateFunctionParameters{
			ForeignFunctionName: f.Name,
			ProtobufRequestStruct: f.RequestName,
			ProtobufResponseStruct: f.ResponseName,
			ExpandedParameters: make([]*HostTemplateFunctionParameterData, 0),
			ExpandedReturn: make([]*HostTemplateFunctionParameterData, 0),
		}

		// generate parameters
		for _, p := range f.Parameters{
			funcParams.ExpandedParameters = append(funcParams.ExpandedParameters, NewHostTemplateFunctionParameterData(p))
		}

		for _, r := range f.Return{
			funcParams.ExpandedReturn = append(funcParams.ExpandedReturn, NewHostTemplateFunctionParameterData(r))
		}

		modParams.Functions = append(modParams.Functions, funcParams)
	}

	this.Modules = append(this.Modules, modParams)
}
//--------------------------------------------------------------------
func (this *HostTemplateParameters) Generate() (string, error){

	if this.ProtoIDLFilename == ""{
		return "", fmt.Errorf("ProtoIDLFilename is empty")
	}

	if this.ProtobufFilename == ""{
		return "", fmt.Errorf("ProtobufFilename is empty")
	}

	if this.Modules == nil || len(this.Modules) == 0{
		return "", fmt.Errorf("No functions defined")
	}

	for _, m := range this.Modules {

		if m.Name == ""{
			return "", fmt.Errorf("Module name is empty")
		}

		for _, f := range m.Functions {
			if f.ForeignFunctionName == "" {
				return "", fmt.Errorf("ForeignFunctionName is empty")
			}

			if f.ProtobufRequestStruct == "" {
				return "", fmt.Errorf("ProtobufRequestStruct is empty")
			}

			if f.ProtobufResponseStruct == "" {
				return "", fmt.Errorf("ProtobufResponseStruct is empty")
			}

			if f.ExpandedParameters == nil {
				return "", fmt.Errorf("ExpandedParameters is nil")
			}

			if f.ExpandedParameters == nil {
				return "", fmt.Errorf("ExpandedParameters is nil")
			}
		}
	}


	temp, err := template.New("Guest").Parse(HostTemplate)
	if err != nil{
		return "", fmt.Errorf("Failed to parse HostTemplate, err: %v", err)
	}

	strbuf := strings.Builder{}

	err = temp.Execute(&strbuf, this)
	if err != nil{
		return "", fmt.Errorf("Failed to execute guest template, err: %v", err)
	}

	return strbuf.String(), nil
}
//--------------------------------------------------------------------
//--------------------------------------------------------------------
//--------------------------------------------------------------------
func NewHostTemplateFunctionParameters(foreignFunctionName string, protobufRequestStruct string, protobufResponseStruct string) *HostTemplateFunctionParameters{
	return &HostTemplateFunctionParameters{
		ForeignFunctionName:    foreignFunctionName,
		ProtobufRequestStruct:  protobufRequestStruct,
		ProtobufResponseStruct: protobufResponseStruct,
	}
}
//--------------------------------------------------------------------