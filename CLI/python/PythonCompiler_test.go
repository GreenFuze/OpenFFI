package main

import (
	"fmt"
	"testing"
)

//--------------------------------------------------------------------
func TestGuestTemplate(t *testing.T){

	guestCompiler := GuestTemplateParameters{
		ProtoIDLFilename:       "test.proto",
		ProtobufFilename:       "prototest_pb.py",
		ForeignFunctionModule:  "foreignfuncfile.py",
		Functions: []*GuestTemplateFunctionParameters{
			&GuestTemplateFunctionParameters{
				ForeignFunctionName:    "foreignfunc1",
				ProtobufRequestStruct:  "foreignfuncParams1",
				ProtobufResponseStruct: "foreignfuncResponse1",
				ExpandedParameters:     []string{"p11", "p12"},
				ExpandedReturn:         []string{"r11", "r12"},
			},

			&GuestTemplateFunctionParameters{
				ForeignFunctionName:    "foreignfunc2",
				ProtobufRequestStruct:  "foreignfuncParams2",
				ProtobufResponseStruct: "foreignfuncResponse2",
				ExpandedParameters:     []string{"p21", "p22"},
				ExpandedReturn:         []string{"r21", "r22"},
			},
		},
	}
/*
	expected := `
# Code generated by OpenFFI. DO NOT EDIT.
# Guest code for test.proto

from prototest_pb.py import *
from foreignfuncfile.py import foreignfunc as Foreignforeignfunc

# Call to foreign foreignfunc
def foreignfunc(paramsVal: bytes) -> ReturnVal:
	
	req = foreignfuncParams()
	req.ParseFromString(str(paramsVal))

	ret = foreignfuncResponse()

	# python method to call a function without knowing its parameter names?

	 res.r1, res.r2 = foreignfuncfile.py.Foreignforeignfunc( req.p1, req.p2)

	return bytes(ret.SerializeToString(), 'utf-8')
`*/

	guestCode, err := guestCompiler.Generate()
	if err != nil{
		t.Fatalf("Failed to generate guest code: %v", err)
	}

	/*
	if guestCode != expected{
		t.Fatalf("Generated code is different than expected.\n\nGenerated: \"%v\"\n\nExpected \"%v\"", guestCode, expected)
	}*/

	fmt.Println(guestCode)
}
//--------------------------------------------------------------------
func TestProtoParserToJSON(t *testing.T){

	proto := `
syntax = "proto3";

//--------------------------------------------------------------------
service Service1 { // module containing foreign functions
    rpc F1 (Params1) returns (Return1); 
	rpc F2 (Params2) returns (Return2);
}
//--------------------------------------------------------------------
// param1 comment
message Params1 {
    repeated string p1 = 1; // param1 inline-comment
}
//--------------------------------------------------------------------
message Return1 {
    string r1 = 1;
}
//--------------------------------------------------------------------
message Params2 {
    string p21 = 1;
	Params1 p22 = 2;
}
//--------------------------------------------------------------------
message Return2 {
    string r21 = 1;
	Return1 r22 = 2;
}
//--------------------------------------------------------------------
`

	parser, err := NewProtoParser(proto, "test.proto")
	if err != nil{
		t.Fatalf("Failed to create proto pparser. Error: %v", err)
	}

	mods, err := parser.GetModules()
	if err != nil{
		t.Fatalf("Failed to get modules: %v", err)
	}

	if len(mods) != 1{
		t.Fatalf("Expected 1 module. Found: %v", len(mods))
	}

	// Test Service1
	if mods[0].Name != "Service1"{
		t.Fatalf("Expected service name to be Service1. Found: %v", mods[0].Name)
	}

	if len(mods[0].Functions) != 2{
		t.Fatalf("Expected Service1 to have 2 functions Found: %v", mods[0].Functions)
	}

	// Test Function F1
	if mods[0].Functions[0].Name != "F1"{
		t.Fatalf("Expected F1 as function name. Got: %v", mods[0].Functions[0].Name)
	}

	if len(mods[0].Functions[0].Parameters) != 1{
		t.Fatalf("F1 should have 1 parameter. Got: %v", len(mods[0].Functions[0].Parameters))
	}

	if len(mods[0].Functions[0].Return) != 1{
		t.Fatalf("F1 should have 1 return value. Got: %v", len(mods[0].Functions[0].Return))
	}

	expectedParameterF1 := ParameterData{
		Name:          "p1",
		Type:          "string",
		IsArray:       true,
	}
	if *mods[0].Functions[0].Parameters[0] != expectedParameterF1{
		t.Fatalf("F1 parameters parsed incorrectly. Got: %v", *mods[0].Functions[0].Parameters[0])
	}

	expectedReturnF1 := ParameterData{
		Name:          "r1",
		Type:          "string",
		IsArray:       false,
	}
	if *mods[0].Functions[0].Return[0] != expectedReturnF1{
		t.Fatalf("F1 Return parsed incorrectly. Got: %v", *mods[0].Functions[0].Return[0])
	}


	// Test function F2
	if mods[0].Functions[1].Name != "F2"{
		t.Fatalf("Expected F2 as function name. Got: %v", mods[0].Functions[1].Name)
	}

	if len(mods[0].Functions[1].Parameters) != 2{
		t.Fatalf("F2 should have 2 parameter. Got: %v", len(mods[0].Functions[1].Parameters))
	}

	if len(mods[0].Functions[1].Return) != 2{
		t.Fatalf("F2 should have 2 return value. Got: %v", len(mods[0].Functions[1].Return))
	}

	expectedParameterFP21 := ParameterData{
		Name:          "p21",
		Type:          "string",
		IsArray:       false,
	}
	if *mods[0].Functions[1].Parameters[0] != expectedParameterFP21{
		t.Fatalf("F2 parameter p21 parsed incorrectly. Got: %v", *mods[0].Functions[1].Parameters[0])
	}

	expectedParameterFP22 := ParameterData{
		Name:          "p22",
		Type:          "Params1",
		IsArray:       false,
	}
	if *mods[0].Functions[1].Parameters[1] != expectedParameterFP22{
		t.Fatalf("F2 parameters p22 parsed incorrectly. Got: %v", *mods[0].Functions[1].Parameters[1])
	}

	expectedReturnFR21 := ParameterData{
		Name:          "r21",
		Type:          "string",
		IsArray:       false,
	}
	if *mods[0].Functions[1].Return[0] != expectedReturnFR21{
		t.Fatalf("F2 Return r21 parsed incorrectly. Got: %v", *mods[0].Functions[1].Return[0])
	}

	expectedReturnFR22 := ParameterData{
		Name:          "r22",
		Type:          "Return1",
		IsArray:       false,
	}
	if *mods[0].Functions[1].Return[1] != expectedReturnFR22{
		t.Fatalf("F2 Return r22 parsed incorrectly. Got: %v", *mods[0].Functions[1].Return[1])
	}


}
//--------------------------------------------------------------------
