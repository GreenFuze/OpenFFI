//+build host
// Code generated by OpenFFI. DO NOT EDIT.
// Guest code for test.proto


package main

import "fmt"
import "unsafe"
import "github.com/golang/protobuf/proto"

/*
void* xllr_handle = NULL;
void* call = NULL;

#ifdef _WIN32
#include <Windows.h>
void* load_library(const char* name, char** out_err)
{
	void* handle = LoadLibraryA(name);
	if(!handle)
	{
		*out_err = GetLastError();
	}

	return handle;
}

const char* free_library(void* lib) // return error string. null if no error.
{
	if(!lib)
	{
		return NULL;
	}

	if(!FreeLibrary(lib))
	{
		return GetLastError();
	}

	return NULL;
}
#else
#include <dlfcn.h>
void* load_library(const char* name, char** out_err)
{
	void* handle = dlopen(name, RTLD_NOW);
	if(!handle)
	{
		*out_err = dlerror();
	}

	return handle;
}

const char* free_library(void* lib)
{
	if(dlclose(lib))
	{
		*out_err = dlerror();
	}

	return NULL;
}

#endif
*/
import "C"

func freeXLLR() error{
	errstr := free_library(C.xllr_handle)

	if errstr != nil{
		return fmt.Sprintf("Failed to free XLLR: %v", C.GoString(errstr))
	}

	return nil
}

func loadXLLR() error{
	var name string
	if runtime.GOOS == "darwin" {
		name = C.CString("xllr.dylib")
	}else if runtime.GOOS == "windows"{
		name = C.CString("xllr.dll")
	} else {
		name = C.CString("xllr.so")
	}

	defer C.free(name)

	var out_err *C.char
	if C.xllr_handle = C.load_library(name, unsafe.pointer(out_err))
		C.xllr_handle == nil{ // error has occurred
		return fmt.Errorf("Failed to load XLLR: %v", C.GoString(out_err))
	}

	return nil
}



// Code to call foreign functions in module Service1 via XLLR



// Call to foreign F1
func F1( P1 []string) (R1 string, err error){

	// serialize parameters
	req := Params1{}

	req.P1 = P1


	// load XLLR
	loadXLLR()

	// call function
	runtime_plugin := "xllr.go"
	pruntime_plugin := C.CString(runtime_plugin)
	defer C.free(pruntime_plugin)

	module_name := "test_openffi_guest"
	pmodule_name := C.CString(module_name)
	defer C.free(pmodule_name)

	func_name := "ForeignF1"
	pfunc_name := C.CString(func_name)
	defer C.free(pfunc_name)

	// in parameters
	in_params, err := proto.Marshal(req)
	if err != nil{
		err = fmt.Errorf("Failed to marshal return values into protobuf. Error: %v", err)
		return
	}

	in_params_len = c_uint64(len(in_params))

	var out_ret *C.char
	*out_ret = nil

	var out_ret_len *C.ulonglong
	*out_ret_len = 0

	var out_params *C.char
	*out_params = nil

	var out_params_len *C.ulonglong
	*out_params_len = 0

	var out_is_error *C.char
	*out_is_error = 0

	C.call(runtime_plugin, len(runtime_plugin),
		pmodule_name, len(module_name),
		pfunc_name, len(func_name),
		pin_params, in_params_len,
		&out_params, out_params_len,
		&out_ret, out_ret_len,
		&out_is_error)

	// check errors
	if *out_is_error != 0{
		err = fmt.Errorf("Function failed. Error: %v", C.GoStringN(out_ret, *out_ret_len))
		return
	}

	// deserialize result
	ret := Return1{}
	out_ret_buf := C.GoStringN(out_ret, *out_ret_len)
	err = proto.Unmarshal([]byte(out_ret_buf), &ret)
	if err != nil{
		err = fmt.Errorf("Failed to unmarshal return values into protobuf. Error: %v", err)
		return
	}

	return ret.R1, nil

}


// Call to foreign F2
func F2( P21 string, P22 Params1) (R21 string,R22 Return1, err error){

	// serialize parameters
	req := Params2{}

	req.P21 = P21

	req.P22 = P22


	// load XLLR
	loadXLLR()

	// call function
	runtime_plugin := "xllr.go"
	pruntime_plugin := C.CString(runtime_plugin)
	defer C.free(pruntime_plugin)

	module_name := "test_openffi_guest"
	pmodule_name := C.CString(module_name)
	defer C.free(pmodule_name)

	func_name := "ForeignF2"
	pfunc_name := C.CString(func_name)
	defer C.free(pfunc_name)

	// in parameters
	in_params, err := proto.Marshal(req)
	if err != nil{
		err = fmt.Errorf("Failed to marshal return values into protobuf. Error: %v", err)
		return
	}

	in_params_len = c_uint64(len(in_params))

	var out_ret *C.char
	*out_ret = nil

	var out_ret_len *C.ulonglong
	*out_ret_len = 0

	var out_params *C.char
	*out_params = nil

	var out_params_len *C.ulonglong
	*out_params_len = 0

	var out_is_error *C.char
	*out_is_error = 0

	C.call(runtime_plugin, len(runtime_plugin),
		pmodule_name, len(module_name),
		pfunc_name, len(func_name),
		pin_params, in_params_len,
		&out_params, out_params_len,
		&out_ret, out_ret_len,
		&out_is_error)

	// check errors
	if *out_is_error != 0{
		err = fmt.Errorf("Function failed. Error: %v", C.GoStringN(out_ret, *out_ret_len))
		return
	}

	// deserialize result
	ret := Return2{}
	out_ret_buf := C.GoStringN(out_ret, *out_ret_len)
	err = proto.Unmarshal([]byte(out_ret_buf), &ret)
	if err != nil{
		err = fmt.Errorf("Failed to unmarshal return values into protobuf. Error: %v", err)
		return
	}

	return ret.R21,ret.R22, nil

}



