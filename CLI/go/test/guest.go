
// Code generated by OpenFFI. DO NOT EDIT.
// Guest code for test.proto

package main

import "C"
import "fmt"
import "github.com/golang/protobuf/proto"

// import all modules
import(

	m0 "Service1"

)

func errToOutError(out_err **C.char, out_err_len *C.ulonglong, is_error *C.char, customText string, err error){
	*is_error = 1
	txt := customText+err.Error()
	*out_err = C.CString(txt)
	*out_err_len = C.ulonglong(len(txt))
}

func panicHandler(out_err **C.char, out_err_len *C.ulonglong, is_error *C.char){
	if rec := recover(); rec != nil{
		msg := "Panic in Go function. Panic Data: "
		switch recType := rec.(type){
		case error: msg += (rec.(error)).Error()
		case string: msg += rec.(string)
		default: msg += fmt.Sprintf("%v", rec)
		}
	}
}

// add functions




// Call to foreign F1
//export ForeignF1
func ForeignF1(in_params *C.char, in_params_len C.ulonglong, out_params **C.char, out_params_len *C.ulonglong, out_ret **C.char, out_ret_len *C.ulonglong, is_error *C.char){

	// catch panics and return them as errors
	defer panicHandler(out_ret, out_ret_len, is_error)

	*is_error = 0

	// deserialize parameters
	inParams := C.GoStringN(in_params, C.int(in_params_len))
	req := Params1{}
	err := proto.Unmarshal([]byte(inParams), &req)
	if err != nil{
		errToOutError(out_ret, out_ret_len, is_error, "Failed to unmarshal parameters", err)
		return
	}

	// call original function
	R1 := m0.F1( req.P1)

	ret := Return1{}

	// === fill out_ret
	// if one of the returned parameters is of interface type Error, check if error, and if so, return error

	if err, isError := interface{}(R1).(error); isError{
		errToOutError(out_ret, out_ret_len, is_error, "Error returned", err)
		return
	} else {
		ret.R1 = R1
	}


	// serialize results
	serializedRet, err := proto.Marshal(ret)
	if err != nil{
		errToOutError(out_ret, out_ret_len, is_error, "Failed to marshal return values into protobuf", err)
		return
	}

	// write serialized results to out_ret
	serializedRetStr := serializedRet.String()
	*out_ret = C.CString(serializedRetStr)
	*out_ret_len = C.ulonglong(len(serializedRetStr))

	// === fill out_params
	serializedParams, err := proto.Marshal(req)
	if err != nil{
		errToOutError(out_ret, out_ret_len, is_error, "Failed to marshal parameter values into protobuf", err)
		return
	}

	// write serialized parameters to out_params
	serializedParamsStr := serializedParams.String()
	*out_ret = C.CString(serializedParamsStr)
	*out_ret_len = C.ulonglong(len(serializedParamsStr))

}



// Call to foreign F2
//export ForeignF2
func ForeignF2(in_params *C.char, in_params_len C.ulonglong, out_params **C.char, out_params_len *C.ulonglong, out_ret **C.char, out_ret_len *C.ulonglong, is_error *C.char){

	// catch panics and return them as errors
	defer panicHandler(out_ret, out_ret_len, is_error)

	*is_error = 0

	// deserialize parameters
	inParams := C.GoStringN(in_params, C.int(in_params_len))
	req := Params2{}
	err := proto.Unmarshal([]byte(inParams), &req)
	if err != nil{
		errToOutError(out_ret, out_ret_len, is_error, "Failed to unmarshal parameters", err)
		return
	}

	// call original function
	R21,R22 := m0.F2( req.P21, req.P22)

	ret := Return2{}

	// === fill out_ret
	// if one of the returned parameters is of interface type Error, check if error, and if so, return error

	if err, isError := interface{}(R21).(error); isError{
		errToOutError(out_ret, out_ret_len, is_error, "Error returned", err)
		return
	} else {
		ret.R21 = R21
	}

	if err, isError := interface{}(R22).(error); isError{
		errToOutError(out_ret, out_ret_len, is_error, "Error returned", err)
		return
	} else {
		ret.R22 = R22
	}


	// serialize results
	serializedRet, err := proto.Marshal(ret)
	if err != nil{
		errToOutError(out_ret, out_ret_len, is_error, "Failed to marshal return values into protobuf", err)
		return
	}

	// write serialized results to out_ret
	serializedRetStr := serializedRet.String()
	*out_ret = C.CString(serializedRetStr)
	*out_ret_len = C.ulonglong(len(serializedRetStr))

	// === fill out_params
	serializedParams, err := proto.Marshal(req)
	if err != nil{
		errToOutError(out_ret, out_ret_len, is_error, "Failed to marshal parameter values into protobuf", err)
		return
	}

	// write serialized parameters to out_params
	serializedParamsStr := serializedParams.String()
	*out_ret = C.CString(serializedParamsStr)
	*out_ret_len = C.ulonglong(len(serializedParamsStr))

}





