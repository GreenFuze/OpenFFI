package main

import (
	"fmt"
	"strings"
	"text/template"
	. "github.com/GreenFuze/OpenFFI/CLI/utils/go"
)

const GuestTemplate = `
// Code generated by OpenFFI. DO NOT EDIT.
// Guest code for {{.ProtoIDLFilename}}

package main

import "C"
import "fmt"
import "github.com/golang/protobuf/proto"

// import all modules
import(
{{range $mindex, $m := .Modules}}
	m{{mindex}} "{{$m.Name}}"
{{end}}
)

func errToOutError(out_err **C.char, out_err_len *C.ulonglong, is_error *C.char, customText string, err error){
	*is_error = 1
	txt := customText+err.Error()
	*out_err = C.CString(txt)
	*out_err_len = C.ulonglong(len(txt))
}

func panicHandler(out_err **C.char, out_err_len *C.ulonglong, is_error *C.char){
	if rec := recover(); rec != nil{
		msg := "Panic in Go function. Panic Data: "
		switch recType := rec.(type){
			case error: msg += (rec.(error)).Error()
			case string: msg += rec.(string)
			default: msg += fmt.Sprintf("%v", rec)
		}
	}
}

// add functions
{{range $mindex, $m := .Modules}}

{{range $findex, $f := $m.Functions}}

// Call to foreign {{.ForeignFunctionName}}
//export Foreign{{$f.ForeignFunctionName}}
func Foreign{{$f.ForeignFunctionName}}(in_params *C.char, in_params_len C.ulonglong, out_params **C.char, out_params_len *C.ulonglong, out_ret **C.char, out_ret_len *C.ulonglong, is_error *C.char){

	// catch panics and return them as errors
	defer panicHandler(out_ret, out_ret_len, is_error)
	
	*is_error = 0

	// deserialize parameters
	inParams := C.GoStringN(in_params, C.int(in_params_len))
	req := {{$f.ProtobufRequestStruct}}{}
	err := proto.Unmarshal(inParams, req)
	if err != nil{
		errToOutError(out_ret, out_ret_len, is_error, "Failed to unmarshal parameters" err)
		return
	}
	
	// call original function
	{{range $index, $elem := $f.ExpandedReturn}}{{if $index}},{{end}}{{$elem}}{{end}}{{if $f.ExpandedReturn}} := {{end}}m{{mindex}}.{{$f.ForeignFunctionName}}({{range $index, $elem := $f.ExpandedParameters}}{{if $index}},{{end}} req.{{$elem}}{{end}})
	
	ret = {{$f.ProtobufResponseStruct}}{}

	// === fill out_ret
	// if one of the returned parameters is of interface type Error, check if error, and if so, return error
	{{range $index, $elem := $f.ExpandedReturn}}
	if err, isError := {{$elem}}.(error); isError && err != nil{
		errToOutError(out_ret, out_ret_len, is_error, "Error returned" err)
		return
	} else {
		ret.{{$elem}} = {{$elem}}
	}	
	{{end}}

	// serialize results
	serializedRet, err := proto.Marshal(ret)
	if err != nil{
		errToOutError(out_ret, out_ret_len, is_error, "Failed to marshal return values into protobuf" err)
		return
	}

	// write serialized results to out_ret
	serializedRetStr := serializedRet.String()
	*out_ret = C.CString(serializedRetStr)
	*out_ret_len = C.ulonglong(len(serializedRetStr))

	// === fill out_params
	// TODO: serialize parameters
	serializedParams, err := proto.Marshal(req)
	if err != nil{
		errToOutError(out_ret, out_ret_len, is_error, "Failed to marshal parameter values into protobuf" err)
		return
	}
	
	// write serialized parameters to out_params
	serializedParamsStr := serializedParams.String()
	*out_ret = C.CString(serializedParamsStr)
	*out_ret_len = C.ulonglong(len(serializedParamsStr))
	
}

{{end}}
`

//--------------------------------------------------------------------
type GuestTemplateParameters struct {
	ProtoIDLFilename       string
	ProtobufFilename       string

	Modules []*GuestTemplateModuleParameters
}
//--------------------------------------------------------------------
type GuestTemplateModuleParameters struct {
	Name string
	Functions []*GuestTemplateFunctionParameters
}
//--------------------------------------------------------------------
type GuestTemplateFunctionParameters struct {
	ForeignFunctionName    string
	ProtobufRequestStruct  string
	ProtobufResponseStruct string
	ExpandedParameters     []string
	ExpandedReturn         []string
}
//--------------------------------------------------------------------
func NewGuestTemplateParameters(protoIDLFilename string) (*GuestTemplateParameters, error){

	extensionIndex := strings.LastIndex(protoIDLFilename, ".")
	if extensionIndex == -1{
		return nil, fmt.Errorf("Cannot find extension in proto filename: %v", protoIDLFilename)
	}

	protoFilenameWithoutExtension := protoIDLFilename[:extensionIndex]

	gtp := &GuestTemplateParameters{
		ProtoIDLFilename: protoIDLFilename,
		ProtobufFilename: protoFilenameWithoutExtension + PROTOBUF_PYTHON_SUFFIX,
	}

	gtp.Modules = make([]*GuestTemplateModuleParameters, 0)

	return gtp, nil
}
//--------------------------------------------------------------------
func (this *GuestTemplateParameters) AddModule(m *Module){

	// add modules
	modParams := &GuestTemplateModuleParameters{
		Name:      m.Name,
		Functions: make([]*GuestTemplateFunctionParameters, 0),
	}

	// for each module, add the function

	for _, f := range m.Functions{

		funcParams := &GuestTemplateFunctionParameters{
			ForeignFunctionName: f.Name,
			ProtobufRequestStruct: f.RequestName,
			ProtobufResponseStruct: f.ResponseName,
			ExpandedParameters: make([]string, 0),
			ExpandedReturn: make([]string, 0),
		}

		// generate parameters
		for _, p := range f.Parameters{
			funcParams.ExpandedParameters = append(funcParams.ExpandedParameters, p.Name)
		}

		for _, r := range f.Return{
			funcParams.ExpandedReturn = append(funcParams.ExpandedReturn, r.Name)
		}

		modParams.Functions = append(modParams.Functions, funcParams)
	}

	this.Modules = append(this.Modules, modParams)
}
//--------------------------------------------------------------------
func (this *GuestTemplateParameters) Generate() (string, error){

	if this.ProtoIDLFilename == ""{
		return "", fmt.Errorf("ProtoIDLFilename is empty")
	}

	if this.ProtobufFilename == ""{
		return "", fmt.Errorf("ProtobufFilename is empty")
	}

	if this.Modules == nil || len(this.Modules) == 0{
		return "", fmt.Errorf("No functions defined")
	}

	for _, m := range this.Modules {

		if m.Name == ""{
			return "", fmt.Errorf("Module name is empty")
		}

		for _, f := range m.Functions {
			if f.ForeignFunctionName == "" {
				return "", fmt.Errorf("ForeignFunctionName is empty")
			}

			if f.ProtobufRequestStruct == "" {
				return "", fmt.Errorf("ProtobufRequestStruct is empty")
			}

			if f.ProtobufResponseStruct == "" {
				return "", fmt.Errorf("ProtobufResponseStruct is empty")
			}

			if f.ExpandedParameters == nil {
				return "", fmt.Errorf("ExpandedParameters is nil")
			}

			if f.ExpandedParameters == nil {
				return "", fmt.Errorf("ExpandedParameters is nil")
			}
		}
	}


	temp, err := template.New("Guest").Parse(GuestTemplate)
	if err != nil{
		return "", fmt.Errorf("Failed to parse GuestTemplate, err: %v", err)
	}

	strbuf := strings.Builder{}

	err = temp.Execute(&strbuf, this)
	if err != nil{
		return "", fmt.Errorf("Failed to execute guest template, err: %v", err)
	}

	return strbuf.String(), nil
}
//--------------------------------------------------------------------
//--------------------------------------------------------------------
//--------------------------------------------------------------------
func NewGuestTemplateFunctionParameters(foreignFunctionName string, protobufRequestStruct string, protobufResponseStruct string) *GuestTemplateFunctionParameters{
	return &GuestTemplateFunctionParameters{
		ForeignFunctionName:    foreignFunctionName,
		ProtobufRequestStruct:  protobufRequestStruct,
		ProtobufResponseStruct: protobufResponseStruct,
	}
}
//--------------------------------------------------------------------
func (this *GuestTemplateFunctionParameters) AddParameters(parameters ...string){
	this.ExpandedParameters = append(this.ExpandedParameters, parameters...)
}
//--------------------------------------------------------------------
func (this *GuestTemplateFunctionParameters) AddReturnParameters(parameters ...string){
	this.ExpandedReturn = append(this.ExpandedReturn, parameters...)
}
//--------------------------------------------------------------------