package main

import (
	"fmt"
	"strings"
	"text/template"
	. "github.com/GreenFuze/OpenFFI/CLI/utils/go"
)

const HostTemplate = `
// Code generated by OpenFFI. DO NOT EDIT.
// Guest code for {{.ProtoIDLFilename}}
{{ $pfn := .ProtoIDLFilenameNoExtension}}

package main

import "fmt"
import "unsafe"
import "github.com/golang/protobuf/proto"

/*
void* xllr_handle = NULL;
void* call = NULL;

#ifdef _WIN32
#include <Windows.h>
void* load_library(const char* name, char** out_err)
{
	void* handle = LoadLibraryA(name);
	if(!handle)
	{
		*out_err = GetLastError();
	}

	return handle;
}

const char* free_library(void* lib) // return error string. null if no error.
{
	if(!lib)
	{
		return NULL;
	}

	if(!FreeLibrary(lib))
	{
		return GetLastError();
	}

	return NULL;
}
#else
#include <dlfcn.h>
void* load_library(const char* name, char** out_err)
{
	void* handle = dlopen(name, RTLD_NOW);
	if(!handle)
	{
		*out_err = dlerror();
	}

	return handle;
}

const char* free_library(void* lib)
{
	if(dlclose(lib))
	{
		*out_err = dlerror();
	}

	return NULL;
}

#endif
*/
import "C"

func freeXLLR() error{
	errstr := free_library(C.xllr_handle)

	if errstr != nil{
		return fmt.Sprintf("Failed to free XLLR: %v", C.GoString(errstr))
	}

	return nil
}

func loadXLLR() error{
	var name string
	if runtime.GOOS == "darwin" {
		name = C.CString("xllr.dylib")
	}else if runtime.GOOS == "windows"{
		name = C.CString("xllr.dll")
	} else {
		name = C.CString("xllr.so")
	}

	defer C.free(name)

	var out_err C.char*
	C.xllr_handle := C.load_library(name, unsafe.pointer(out_err))
	C.xllr_handle == nil{ // error has occurred
		return fmt.Errorf("Failed to load XLLR: %v", C.GoString(out_err))
	}

	return nil
}

{{range $mindex, $m := .Modules}}

// Code to call foreign functions in module {{$m.Name}} via XLLR

{{range $findex, $f := $m.Functions}}

// Call to foreign {{.ForeignFunctionName}}
func {{$f.ForeignFunctionName}}({{range $index, $elem := $f.ExpandedParameters}}{{if $index}},{{end}} {{$elem.Name}}:{{$elem.Type}}{{end}}) ({{range $index, $elem := $f.ExpandedReturn}}{{if $index}},{{end}}{{$elem.Name}} {{$elem.Type}}{{end}}, err error){

	// serialize parameters
	req := {{$f.ProtobufRequestStruct}}{}
	{{range $index, $elem := $f.ExpandedParameters}}
	req.{{$elem.Name}} = {{$elem.Name}}
	{{end}}

	// load XLLR
	loadXLLR()
	
	// call function
	runtime_plugin := "xllr.go"
	pruntime_plugin := C.CString(runtime_plugin)
	defer C.free(pruntime_plugin)

	module_name := "{{$pfn}}_openffi_guest"
	pmodule_name := C.CString(module_name)
	defer C.free(pmodule_name)

	func_name := "Foreign{{$f.ForeignFunctionName}}"
	pfunc_name := C.CString(func_name)
	defer C.free(pfunc_name)

	// in parameters
	in_params, err := proto.Marshal(req)
	if err != nil{
		err = fmt.Errorf("Failed to marshal return values into protobuf. Error: %v", err)
		return
	}

	in_params_len = c_uint64(len(in_params))

	var out_ret C.char*
	*out_ret = nil

	var out_ret_len C.ulonglong*
	*out_ret_len = 0 

	var out_params C.char*
	*out_params = nil

	var out_params_len C.ulonglong*
	*out_params_len = 0

	var out_is_error C.char*
	*out_is_error = 0

	C.call(runtime_plugin, len(runtime_plugin),
			pmodule_name, len(module_name),
			pfunc_name, len(func_name),
			pin_params, in_params_len,
			&out_params, out_params_len,
			&out_ret, out_ret_len,
			&out_is_error)

	// check errors
	if *out_is_error != 0{
		err = fmt.Errorf("Function failed. Error: %v", C.GoStringN(out_ret, *out_ret_len))
		return
	}

	// deserialize result	
	ret := {{$f.ProtobufResponseStruct}}{}
	out_ret_buf := C.GoStringN(out_ret, *out_ret_len)
	err := proto.Unmarshal([]byte(out_ret_buf), ret)
	if err != nil{
		err = fmt.Errorf("Failed to unmarshal return values into protobuf. Error: %v", err)
		return
	}

	return {{range $index, $elem := $f.ExpandedReturn}}{{if $index}},{{end}}ret.{{$elem.Name}}{{end}}, nil

}
{{end}}

{{end}}
`

//--------------------------------------------------------------------
type HostTemplateParameters struct {
	ProtoIDLFilename       		string
	ProtoIDLFilenameNoExtension string
	ProtobufFilename       		string

	Modules []*HostTemplateModuleParameters
}
//--------------------------------------------------------------------
type HostTemplateModuleParameters struct {
	Name string
	Functions []*HostTemplateFunctionParameters
}
//--------------------------------------------------------------------
type HostTemplateFunctionParameters struct {
	ForeignFunctionName    string
	ProtobufRequestStruct  string
	ProtobufResponseStruct string
	ExpandedParameters     []*HostTemplateFunctionParameterData
	ExpandedReturn         []*HostTemplateFunctionParameterData
}
//--------------------------------------------------------------------
type HostTemplateFunctionParameterData struct {
	Name string
	Type string
}
//--------------------------------------------------------------------
func NewHostTemplateParameters(protoIDLFilename string) (*HostTemplateParameters, error){

	extensionIndex := strings.LastIndex(protoIDLFilename, ".")
	if extensionIndex == -1{
		return nil, fmt.Errorf("Cannot find extension in proto filename: %v", protoIDLFilename)
	}

	protoFilenameWithoutExtension := protoIDLFilename[:extensionIndex]

	gtp := &HostTemplateParameters{
		ProtoIDLFilename: protoIDLFilename,
		ProtoIDLFilenameNoExtension: protoFilenameWithoutExtension,
		ProtobufFilename: protoFilenameWithoutExtension + PROTOBUF_PYTHON_SUFFIX,
	}

	gtp.Modules = make([]*HostTemplateModuleParameters, 0)

	return gtp, nil
}
//--------------------------------------------------------------------
func NewHostTemplateFunctionParameterData(p *ParameterData) *HostTemplateFunctionParameterData{
	htfp := &HostTemplateFunctionParameterData{
		Name: p.Name,
	}

	htfp.Type = ProtoTypeToPythonType(p.Type)
	if p.IsArray{
		htfp.Type = fmt.Sprintf("List[%v]", htfp.Type)
	}

	return htfp
}
//--------------------------------------------------------------------
func (this *HostTemplateParameters) AddModule(m *Module){

	// add modules
	modParams := &HostTemplateModuleParameters{
		Name:      m.Name,
		Functions: make([]*HostTemplateFunctionParameters, 0),
	}

	// for each module, add the function

	for _, f := range m.Functions{

		funcParams := &HostTemplateFunctionParameters{
			ForeignFunctionName: f.Name,
			ProtobufRequestStruct: f.RequestName,
			ProtobufResponseStruct: f.ResponseName,
			ExpandedParameters: make([]*HostTemplateFunctionParameterData, 0),
			ExpandedReturn: make([]*HostTemplateFunctionParameterData, 0),
		}

		// generate parameters
		for _, p := range f.Parameters{
			funcParams.ExpandedParameters = append(funcParams.ExpandedParameters, NewHostTemplateFunctionParameterData(p))
		}

		for _, r := range f.Return{
			funcParams.ExpandedReturn = append(funcParams.ExpandedReturn, NewHostTemplateFunctionParameterData(r))
		}

		modParams.Functions = append(modParams.Functions, funcParams)
	}

	this.Modules = append(this.Modules, modParams)
}
//--------------------------------------------------------------------
func (this *HostTemplateParameters) Generate() (string, error){

	if this.ProtoIDLFilename == ""{
		return "", fmt.Errorf("ProtoIDLFilename is empty")
	}

	if this.ProtobufFilename == ""{
		return "", fmt.Errorf("ProtobufFilename is empty")
	}

	if this.Modules == nil || len(this.Modules) == 0{
		return "", fmt.Errorf("No functions defined")
	}

	for _, m := range this.Modules {

		if m.Name == ""{
			return "", fmt.Errorf("Module name is empty")
		}

		for _, f := range m.Functions {
			if f.ForeignFunctionName == "" {
				return "", fmt.Errorf("ForeignFunctionName is empty")
			}

			if f.ProtobufRequestStruct == "" {
				return "", fmt.Errorf("ProtobufRequestStruct is empty")
			}

			if f.ProtobufResponseStruct == "" {
				return "", fmt.Errorf("ProtobufResponseStruct is empty")
			}

			if f.ExpandedParameters == nil {
				return "", fmt.Errorf("ExpandedParameters is nil")
			}

			if f.ExpandedParameters == nil {
				return "", fmt.Errorf("ExpandedParameters is nil")
			}
		}
	}


	temp, err := template.New("Host").Parse(HostTemplate)
	if err != nil{
		return "", fmt.Errorf("Failed to parse HostTemplate, err: %v", err)
	}

	strbuf := strings.Builder{}

	err = temp.Execute(&strbuf, this)
	if err != nil{
		return "", fmt.Errorf("Failed to execute guest template, err: %v", err)
	}

	return strbuf.String(), nil
}
//--------------------------------------------------------------------
//--------------------------------------------------------------------
//--------------------------------------------------------------------
func NewHostTemplateFunctionParameters(foreignFunctionName string, protobufRequestStruct string, protobufResponseStruct string) *HostTemplateFunctionParameters{
	return &HostTemplateFunctionParameters{
		ForeignFunctionName:    foreignFunctionName,
		ProtobufRequestStruct:  protobufRequestStruct,
		ProtobufResponseStruct: protobufResponseStruct,
	}
}
//--------------------------------------------------------------------