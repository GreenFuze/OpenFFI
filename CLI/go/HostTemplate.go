package main

const HostTemplate = `
// Code generated by OpenFFI. DO NOT EDIT.
// Guest code for {{.ProtoIDLFilename}}
{{ $pfn := .ProtoIDLFilenameNoExtension}}

package main

import "fmt"
import "unsafe"
import "github.com/golang/protobuf/proto"
import "runtime"

// #cgo LDFLAGS: -L. -ldl
/*
#include <stdlib.h>
#include <stdint.h>
void* xllr_handle = NULL;
void (*pcall)(const char*, uint32_t,
			 const char*, uint32_t,
			 const char*, uint32_t,
			 unsigned char*, uint64_t,
			 unsigned char**, uint64_t*,
			 unsigned char**, uint64_t*,
			 uint8_t*) = NULL;

#ifdef _WIN32 //// --- START WINDOWS ---
#include <Windows.h>
void* load_library(const char* name, char** out_err)
{
	void* handle = LoadLibraryA(name);
	if(!handle)
	{
		*out_err = GetLastError();
	}

	return handle;
}

const char* free_library(void* lib) // return error string. null if no error.
{
	if(!lib)
	{
		return NULL;
	}

	if(!FreeLibrary(lib))
	{
		return GetLastError();
	}

	return NULL;
}

void* load_symbol(void* handle, const char* name, char** out_err)
{
	void* res = GetProcAddress(handle, name);
	if(!res)
	{
		*out_err = GetLastError();
		return NULL;
	}

	return res;
}

#else // ------ START POSIX ----
#include <dlfcn.h>
void* load_library(const char* name, char** out_err)
{
	void* handle = dlopen(name, RTLD_NOW);
	if(!handle)
	{
		*out_err = dlerror();
	}

	return handle;
}

const char* free_library(void* lib)
{
	if(dlclose(lib))
	{
		return dlerror();
	}

	return NULL;
}

void* load_symbol(void* handle, const char* name, char** out_err)
{
	void* res = dlsym(handle, name);
	if(!res)
	{
		*out_err = dlerror();
		return NULL;
	}

	return res;
}

#endif // ------- END POSIX -----

void call(
		const char* runtime_plugin, uint32_t runtime_plugin_len,
		const char* module_name, uint32_t module_name_len,
		const char* func_name, uint32_t func_name_len,
		unsigned char* in_params, uint64_t in_params_len,
		unsigned char** out_params, uint64_t* out_params_len,
		unsigned char** out_ret, uint64_t* out_ret_len,
		uint8_t* is_error
)
{
	pcall(runtime_plugin, runtime_plugin_len,
			module_name, module_name_len,
			func_name, func_name_len,
			in_params, in_params_len,
			out_params, out_params_len,
			out_ret, out_ret_len,
			is_error);
}

*/
import "C"

func freeXLLR() error{
	errstr := C.free_library(C.xllr_handle)

	if errstr != nil{
		return fmt.Errorf("Failed to free XLLR: %v", C.GoString(errstr))
	}

	return nil
}

func loadXLLR() error{
	var name *C.char
	if runtime.GOOS == "darwin" {
		name = C.CString("xllr.dylib")
	}else if runtime.GOOS == "windows"{
		name = C.CString("xllr.dll")
	} else {
		name = C.CString("xllr.so")
	}

	defer C.free(unsafe.Pointer(name))

	var out_err *C.char
	if C.xllr_handle = C.load_library(name, &out_err)
	C.xllr_handle == nil{ // error has occurred
		return fmt.Errorf("Failed to load XLLR: %v", C.GoString(out_err))
	}

	return nil
}

{{range $mindex, $m := .Modules}}

// Code to call foreign functions in module {{$m.Name}} via XLLR

{{range $findex, $f := $m.Functions}}

// Call to foreign {{.ForeignFunctionName}}
func {{$f.ForeignFunctionName}}({{range $index, $elem := $f.ExpandedParameters}}{{if $index}},{{end}} {{$elem.Name}} {{$elem.Type}}{{end}}) ({{range $index, $elem := $f.ExpandedReturn}}{{if $index}},{{end}}{{$elem.Name}} {{$elem.Type}}{{end}}, err error){

	// serialize parameters
	req := {{$f.ProtobufRequestStruct}}{}
	{{range $index, $elem := $f.ExpandedParameters}}
	req.{{$elem.Name}} = {{$elem.PointerIfNeeded ""}}
	{{end}}

	// load XLLR
	err = loadXLLR()
	if err != nil{
		err = fmt.Errorf("Failed to marshal return values into protobuf. Error: %v", err)
		return
	}
	
	// call function
	runtime_plugin := "xllr.{{TargetLanguage}}"
	pruntime_plugin := C.CString(runtime_plugin)
	defer C.free(unsafe.Pointer(pruntime_plugin))

	module_name := "{{$pfn}}_openffi_guest"
	pmodule_name := C.CString(module_name)
	defer C.free(unsafe.Pointer(pmodule_name))

	func_name := "Foreign{{$f.ForeignFunctionName}}"
	pfunc_name := C.CString(func_name)
	defer C.free(unsafe.Pointer(pfunc_name))

	// in parameters
	in_params, err := proto.Marshal(&req)
	if err != nil{
		err = fmt.Errorf("Failed to marshal return values into protobuf. Error: %v", err)
		return
	}

	var pin_params *C.uchar
	pin_params = (*C.uchar)(unsafe.Pointer(&in_params[0]))
	in_params_len := C.ulong(len(in_params))

	var out_ret *C.uchar
	var out_ret_len C.ulong
	out_ret_len = C.ulong(0)

	var out_params *C.uchar
	var out_params_len C.ulong
	out_params_len = C.ulong(0)

	var out_is_error C.uchar
	out_is_error = C.uchar(0)

	C.call(pruntime_plugin, C.uint(len(runtime_plugin)),
			pmodule_name, C.uint(len(module_name)),
			pfunc_name, C.uint(len(func_name)),
			pin_params, in_params_len,
			&out_params, &out_params_len,
			&out_ret, &out_ret_len,
			&out_is_error)

	// check errors
	if out_is_error != 0{
		err = fmt.Errorf("Function failed. Error: %v", string(C.GoBytes(unsafe.Pointer(out_ret), C.int(out_ret_len))))
		return
	}

	// deserialize result	
	ret := {{$f.ProtobufResponseStruct}}{}
	out_ret_buf := C.GoBytes(unsafe.Pointer(out_ret), C.int(out_ret_len))
	err = proto.Unmarshal(out_ret_buf, &ret)
	if err != nil{
		err = fmt.Errorf("Failed to unmarshal return values into protobuf. Error: %v", err)
		return
	}

	return {{range $index, $elem := $f.ExpandedReturn}}{{if $index}},{{end}}{{$elem.DereferenceIfNeeded "ret."}}{{end}}, nil

}
{{end}}

{{end}}
`

